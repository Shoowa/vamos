package routes

import (
	"context"
	"errors"
	"net/http"
	"time"

	"_example/metric"
	"_example/sqlc/data/first" // NOT generated in this example

	"github.com/Shoowa/vamos/router"
)

const TIMEOUT_REQUEST = time.Second * 3

// This is a secondary wrapper. It wraps around the library Backbone. It
// indirectly holds the dependencies an executable requires, e.g., Postgres,
// Redis, and a logger. It can directly hold the Query handle generated by sqlC.
type Deps struct {
	*router.Backbone
	Query *first.Queries // NOT generated in this example.
}

// Create a native struct that embeds the Backbone struct and adds sqlC Queries.
func WrapBackbone(b *router.Backbone) *Deps {
	d := &Deps{b, first.New(b.DbHandle)}
	return d
}

// Create a menu of routes, and satisfy the library Gatherer interface by
// writing a function named GetEndpoints that returns a list of Endpoints from
// the library Router pkg. This will help during testing. Deps is emulating the
// library Backbone.
func (d *Deps) GetEndpoints() []router.Endpoint {
	return []router.Endpoint{
		{"GET /test1", d.hndlr1},
		{"GET /test2", d.hndlr2},
		{"GET /readAuthorName/{surname}", d.readAuthorName},
	}
}

// CreateEmptyDeps is useful for creating the backboneWrapper in tests.
func CreateEmptyDeps() *Deps {
	return &Deps{nil, nil}
}

// A simple http.Handler
func (d *Deps) hndlr1(w http.ResponseWriter, req *http.Request) {
	d.Logger.Info("Test1, test1, test1...")
	w.Write([]byte("This is a public service announcement."))
}

// A contrived error demonstrating the ease of the library Backbone method named
// ServerError.
func (d *Deps) hndlr2(w http.ResponseWriter, req *http.Request) {
	d.Logger.Info("2, 2, 2...")
	err := errors.New("Break! Failure! Error!")
	d.ServerError(w, req, err)
}

// A http.Handler that leverages sqlC Queries.
func (d *Deps) readAuthorName(w http.ResponseWriter, req *http.Request) {
	// An arbitrary metric.
	metric.ReadAuthCount.Inc()

	// Read the request value.
	surname := req.PathValue("surname")

	// Use the chain of contexts.
	timer, cancel := context.WithTimeout(req.Context(), TIMEOUT_REQUEST)
	defer cancel()

	// Read data from Postgres.
	result, err := d.Query.GetAuthor(timer, surname)

	// Report a potential error.
	if err != nil {
		d.ServerError(w, req, err)
		return
	}

	// Respond to a user.
	w.Write([]byte(result.Name))
}
